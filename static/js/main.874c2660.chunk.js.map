{"version":3,"sources":["camera.js","vid_filters.js","Video.js","SpeechText.js","App.js","serviceWorker.js","index.js"],"names":["camera","options","video","canvas","context","renderTimer","initVideoStream","a","document","createElement","setAttribute","width","height","navigator","mediaDevices","getUserMedia","facingMode","then","stream","srcObject","onloadedmetadata","e","startCapture","initCanvas","catch","onError","targetCanvas","getContext","mirror","translate","scale","play","setInterval","drawImage","onFrame","Math","round","fps","init","captureOptions","start","pause","clearInterval","p8_pal","rgb_to_pico8","pr","pg","pb","closest_index","closest_distance","Number","MAX_SAFE_INTEGER","i","length","r","g","b","distance","pico8ify","bctx","ctx","w","h","data","getImageData","clearRect","step","new_data","c","floor","fillStyle","fillRect","Video","draw","buf_canvas","getElementById","this","bind","console","log","id","className","React","Component","SpeechText","setup","SpeechRecognition","window","webkitSpeechRecognition","recognition","continuous","lang","interimResults","maxAlternatives","onresult","last","results","transcript","setState","onerror","error","state","App","Boolean","location","hostname","match","ReactDOM","render","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.874c2660.chunk.js","sourcesContent":["var camera = (function() {\n   let options;\n   let video, canvas, context;\n   let renderTimer;\n\n   async function initVideoStream() {\n      video = document.createElement(\"video\");\n      video.setAttribute('width', options.width);\n      video.setAttribute('height', options.height);\n      video.setAttribute('playsinline', 'true');\n      video.setAttribute('webkit-playsinline', 'true');\n\n      if (navigator.mediaDevices) {\n         await navigator.mediaDevices.getUserMedia({\n            video: true,\n            facingMode: \"user\",\n         }).then((stream) => {\n            video.srcObject = stream;\n            video.onloadedmetadata = (e) => {\n               startCapture()\n            };\n\n            initCanvas();\n         }).catch(options.onError);\n      }\n   }\n\n   function initCanvas() {\n      canvas = options.targetCanvas || document.createElement(\"canvas\");\n      canvas.setAttribute('width', options.width);\n      canvas.setAttribute('height', options.height);\n      context = canvas.getContext('2d');\n\n      if (options.mirror) {\n         context.translate(canvas.width, 0);\n         context.scale(-1, 1);\n      }\n   }\n\n   function startCapture() {\n      video.play();\n\n      renderTimer = setInterval(function() {\n         context.drawImage(video, 0, 0, video.width, video.height);\n         options.onFrame(canvas);\n      }, Math.round(1000 / options.fps));\n   }\n\n   function pauseCapture() {\n      if (renderTimer) clearInterval(renderTimer);\n      video.pause()\n   }\n\n   return {\n      init: async function(captureOptions) {\n         options = captureOptions || {};\n\n         options.fps = options.fps || 30;\n         options.mirror = options.mirror || false;\n         options.targetCanvas = options.targetCanvas || null;\n\n         await initVideoStream();\n      },\n\n      start: startCapture,\n      pause: pauseCapture\n   };\n})();\n\nexport { camera };\n","export let DIM = 32\n\nlet p8_pal = [\n   0, 0, 0,\n   29, 43, 83,\n   126, 37, 83,\n   0, 135, 81,\n   171, 82, 54,\n   95, 87, 79,\n   194, 195, 199,\n   255, 241, 232,\n   255, 0, 77,\n   255, 163, 0,\n   255, 236, 39,\n   0, 228, 54,\n   41, 173, 255,\n   131, 118, 156,\n   255, 119, 168,\n   255, 204, 170\n]\n\nlet rgb_to_pico8 = (pr, pg, pb) => {\n   let closest_index = 0\n   let closest_distance = Number.MAX_SAFE_INTEGER\n   for (let i = 0; i < p8_pal.length; i+= 3) {\n      let r = pr - p8_pal[i]\n      let g = pg - p8_pal[i+1]\n      let b = pb - p8_pal[i+2]\n\n      let distance = r*r + g*g + b*b\n      if (distance < closest_distance) {\n         closest_index = i\n         closest_distance = distance\n      }\n   }\n\n   return [\n      p8_pal[closest_index],\n      p8_pal[closest_index+1],\n      p8_pal[closest_index+2]\n   ];\n}\n\nexport let pico8ify = (bctx, ctx, scale) => {\n   let w = scale * DIM\n   let h = scale * DIM\n   let b_im = bctx.getImageData(0, 0, DIM, DIM);\n   let data = b_im.data;\n\n   ctx.clearRect(0,0,w,h)\n   for (let i = 0, step = 0; i < data.length; i += 4, ++step) {\n      let new_data = rgb_to_pico8(data[i], data[i+1], data[i+2])\n      let c = step % DIM\n      let r = Math.floor(step / DIM)\n      ctx.fillStyle = 'rgb(' + new_data[0] + ', ' + new_data[1] + ', ' + new_data[2] + ')';\n      ctx.fillRect(c*scale, r*scale, scale, scale)\n   }\n}\n\n","import React from 'react';\nimport './Video.css';\nimport {camera} from './camera';\nimport {pico8ify, DIM} from './vid_filters';\n\nclass Video extends React.Component {\n   draw = (buf_canvas) => {\n      const bctx = buf_canvas.getContext('2d');\n\n      const canvas = document.getElementById('vid');\n      const ctx = canvas.getContext('2d');\n\n      pico8ify(bctx, ctx, this.scale);\n   };\n\n   scale = 8\n\n   componentDidMount() {\n      camera.init({\n         width: DIM,\n         height: DIM,\n         mirror: true,\n         fps: 30,\n         targetCanvas: document.getElementById('buf'),\n         onFrame: this.draw.bind(),\n         onError: () => {\n            console.log(\"Error bro.\")\n         }\n      },\n      );\n   }\n\n   render() {\n      return <>\n         <canvas id=\"buf\" className=\"buf\"/>\n         <canvas width={DIM*this.scale} height={DIM*this.scale} id=\"vid\" className=\"vid\"/>\n      </>;\n   }\n}\n\nexport default Video;\n","import React from 'react';\nimport './SpeechText.css';\n\n\nclass SpeechText extends React.Component {\n   constructor() {\n      super();\n      this.state = {transcript: \"\"};\n   }\n\n   setup = () => {\n      let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition\n      this.recognition = new SpeechRecognition();\n\n      this.recognition.continuous = true;\n      this.recognition.lang = 'en-US';\n      this.recognition.interimResults = false;\n      this.recognition.maxAlternatives = 1;\n\n      this.recognition.onresult = (e) => {\n         var last = e.results.length - 1;\n         var transcript = e.results[last][0].transcript;\n         this.setState({transcript: transcript + \".\"});\n      }\n\n      this.recognition.onerror = (e) => {\n         this.setState({transcript: 'Error occurred in recognition: ' + e.error});\n      }\n\n      this.recognition.start();\n   }\n\n   componentDidMount() {\n      this.setup();\n   }\n\n   render() {\n      return <>\n         <h1>{this.state.transcript}</h1>\n      </>;\n   }\n}\n\nexport default SpeechText;\n","import React from 'react';\nimport './App.css';\nimport Video from './Video';\nimport SpeechText from './SpeechText';\n\nfunction App() {\n   return <>\n      <Video/>\n      <SpeechText/>\n   </>;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}